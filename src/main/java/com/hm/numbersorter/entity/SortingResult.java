package com.hm.numbersorter.entity;

import java.util.Map;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.NamedNativeQuery;
import javax.persistence.Table;

import org.springframework.util.Assert;

/**
 * @author prabu This class is used as entity mapping class for the tables
 *         resides in H2 database
 */
@Entity
@Table(name = "Sort_Result")
@NamedNativeQuery(name = "SortingResult.findAllWithLimit", query = "SELECT * FROM Sort_Result order by Sort_Id desc limit :rowsLimit", resultClass = SortingResult.class)
public class SortingResult {

	@Id
	@GeneratedValue
	@Column(name = "Sort_Id")
	private int sortId;

	@Column(name = "Input_Numbers")
	private String inputNumbers;
	@Column(name = "Sorted_Numbers")
	private String sortedNumbers;

	@Column(name = "Time_Consumed")
	private String timeConsumed;
	@Column(name = "Position_Swaped")
	private String positionSwaped;

	public SortingResult() {

	}

	/**
	 * Constructor takes four params as sortring metrics and holds the information
	 * to be called by persistence service
	 * 
	 * @param inputNumbers
	 * @param sortedNumbers
	 * @param timeConsumed
	 * @param positionSwaped
	 */
	public SortingResult(String inputNumbers, String sortedNumbers, String timeConsumed, String positionSwaped) {
		this.inputNumbers = inputNumbers;
		this.sortedNumbers = sortedNumbers;
		this.timeConsumed = timeConsumed;
		this.positionSwaped = positionSwaped;
	}

	/**
	 * Consutuctore takes a map holds the required metrics
	 * 
	 * @param constructorMap
	 */
	public SortingResult(Map<String, String> constructorMap) {
		Assert.notEmpty(constructorMap, "Sorting Results can't be empty");
		this.inputNumbers = constructorMap.get("inputNumbers");
		this.sortedNumbers = constructorMap.get("sortedNumbers");
		this.timeConsumed = constructorMap.get("timeConsumed");
		this.positionSwaped = constructorMap.get("positionSwaped");
	}

	/**
	 * get the sortId autogenerated by H2.
	 * 
	 * @return sortId
	 */
	public int getSortId() {
		return sortId;
	}

	/**
	 * set the sortId implicitly.
	 * 
	 * @param sortId
	 */

	public void setSortId(int sortId) {
		this.sortId = sortId;
	}

	/**
	 * get the inputnumbers.
	 * 
	 * @return inputNumbers (a comma separated numbers in string format)
	 */

	public String getInputNumbers() {
		return inputNumbers;
	}

	/**
	 * set the inputNumbers
	 * 
	 * @param inputNumbers
	 */

	public void setInputNumbers(String inputNumbers) {
		this.inputNumbers = inputNumbers;
	}

	/**
	 * get the sortedNumbers.
	 * 
	 * @return sortedNumbers
	 */

	public String getSortedNumbers() {
		return sortedNumbers;
	}

	/**
	 * set the sortedNumbers
	 * 
	 * @param sortedNumbers
	 */

	public void setSortedNumbers(String sortedNumbers) {
		this.sortedNumbers = sortedNumbers;
	}

	/**
	 * get the timeConsumed metric.
	 * 
	 * @return timeConsumed in milli secs as String
	 */

	public String getTimeConsumed() {
		return timeConsumed;
	}

	/**
	 * set the timeConsumed. * @param timeConsumed
	 */

	public void setTimeConsumed(String timeConsumed) {
		this.timeConsumed = timeConsumed;
	}

	/**
	 * get the position swaped
	 * 
	 * @return positionSwaped
	 */
	public String getPositionSwaped() {
		return positionSwaped;
	}

	/**
	 * set the positionSwaped.
	 * 
	 * @param positionSwaped
	 *            (No of swaps occured during sort operation)
	 */

	public void setPositionSwaped(String positionSwaped) {
		this.positionSwaped = positionSwaped;
	}

}
